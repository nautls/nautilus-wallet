---
url: /dapp-connector/api-overview.md
---
# API Overview

Nautilus provides a convenient and easy way for dApps to interact with wallets through its dApp Connector API, also known as EIP-12 protocol. The protocol provides a seamless bridge between your dApp and the user's wallet, enabling secure and efficient communication. This ensures that your dApp can perform necessary operations such as balance checks and transaction signing with the user's permission.

The dApp Connector API is an asynchronous wrapper on top of a `JSON-RPC` protocol that is injected into the browser's page context by the Nautilus Wallet extension. It's divided into two main parts: the **Connection API** and the **Context API**, as described below.

:::warning
**Work-in-Progress**: Non-reviewed text. You may find numerous writing errors throughout this guide.
:::

## Connection API

The Connection API is responsible for handling wallet connection requests and providing initial information about available EIP-12 compatible wallet applications.

EIP-12 compatible browser wallets on Ergo, like Nautilus, automatically inject the **Connection API** into every active page, allowing any page context to interact with it directly through the `ergoConnector` object.

### Multi-wallet support

The Connection API is designed to support multiple wallets. To connect to a wallet, use the `ergoConnector.{walletId}.connect()` method, where `{walletId}` is the wallet of your choice. For our example, we will use `nautilus`.

```ts
await ergoConnector.nautilus.connect();
```

## Context API

The Context API is responsible for handling wallet-related requests such as retrieving balances, signing transactions, and more.

Once the connection request is accepted by the user, this API will be injected similarly to the Connection API, allowing interaction through the `ergo` object. Alternatively it can be returned by the `ergoConnector.nautilus.connect()` method as demonstrated in the [Wallet connection](/dapp-connector/wallet-connection) section.

```ts
await ergo.get_balance();
```

## Static Types

For a better development experience, Nautilus [maintains a static typing library](https://github.com/capt-nemo429/eip12-types) for the dApp Connector protocol. Follow the steps below to get types working in your TypeScript project.

### Step. 1: Install the package

Add `@nautilus-js/eip12-types` as a `dev-dependency`for your project.

::: code-group

```bash [npm]
npm i @nautilus-js/eip12-types -D
```

```bash [pnpm]
pnpm add @nautilus-js/eip12-types -D
```

```bash [bun]
bun add @nautilus-js/eip12-types -D
```

```bash [yarn]
yarn add @nautilus-js/eip12-types -D
```

:::

### Step. 2: Tweak the `tsconfig.json` file

Add `@nautilus-js/eip12-types` to the `compilerOptions.types` array.

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    // ...
    // Add "@nautilus-js/eip12-types" to the types array
    "types": ["@nautilus-js/eip12-types"]
  }
}
```

---

---
url: /dapp-connector/wallet-connection.md
---
# Connecting to a Wallet

The first step in interacting with Nautilus is to request the access to the user. This is done using the `ergoConnector` object, which is automatically injected into the page context by the Nautilus Wallet web extension.

:::warning
**Work-in-Progress**: Non-reviewed text. You may find numerous writing errors throughout this guide.
:::

## Check if Nautilus is running

To check if the user has the Nautilus Wallet installed and running, check for the presence of the `ergoConnector` and then for `ergoConnector.nautilus`.

```ts
if (ergoConnector) { // check if the Connection API is injected // [!code focus]
  if (ergoConnector.nautilus) { // check if the Nautilus Wallet is available // [!code focus]
    console.log("Nautilus is ready to use");
  } else {
    console.log("Nautilus is not available");
  }
} else {
  console.log("No wallet available");
}
```

## Request access

After making sure that the Nautilus Wallet is installed and running, now it's time to request access to the user's wallet. This is done by calling the `ergoConnector.nautilus.connect()` method, as shown below.

```ts
const connected = await ergoConnector.nautilus.connect(); // [!code focus]

if (connected) {
  console.log("Connected!");
} else {
  console.log("Not connected!");
}
```

The first time the `connect()` method is called, Nautilus will pop up and prompt the user to allow or deny access to your dApp. By default, it will return `false` if the user declines, otherwise, it will return `true` and globally inject the `ergo` object which you can use to interact with the [Context API](/dapp-connector/api-overview#context-api). For the subsequent calls, if the dApp is previously, the Nautilus pop-up prompt will be bypassed.

### Avoid globally instantiating of the `ergo` object

Sometimes we need to avoid instantiating the `ergo` object globally, especially when handling multiple wallets. To achieve this, follow these steps:

1. Call `ergoConnector.nautilus.connect({ createErgoObject: false })`. Calling the `connect()` method with the parameter `{ createErgoObject: false }` will request a connection with the user's wallet without automatically instantiating the `ergo` object.
2. Get the context object by calling the `ergoConnector.nautilus.getContext()` method.

```ts
const isConnected = await ergoConnector.nautilus.connect({ createErgoObject: false }); // [!code focus]
if (isConnected) {
  const ergo = await ergoConnector.nautilus.getContext(); // [!code focus]
}
```

### Check for authorization and connection status

Nautilus provides methods to check both the authorization and connection status of your dApp with the wallet.

* `ergoConnector.nautilus.isConnected()`: Checks if there is an active connection between your dApp and Nautilus.
* `ergoConnector.nautilus.isAuthorized()`: Checks if your dApp has been previously authorized by the user.

## Disconnect from the Wallet

You can disconnect from a wallet using the `ergoConnector.nautilus.disconnect()` method, which will revoke your dApp's authorization token. If you need to connect again in the future, the user will be prompted with a new connection request.

---

---
url: /dapp-connector/wallet-interaction.md
---
# Interacting With a Wallet

Once we gain access to the wallet, we can interact with it through the [Context API](/dapp-connector/api-overview#context-api). [As explained earlier](wallet-connection#avoid-globally-instantiating-of-the-ergo-object), this API may or may not be globally injected into your dApp's context, depending on your implementation.

:::warning
**Work-in-Progress**: Non-reviewed text. You may find numerous writing errors throughout this guide.
:::

## Get Balance

Let's start by getting the wallet's balance. To do this, use the `ergo.get_balance()` method.

```ts
const ergBalance = await ergo.get_balance();
```

By default the `get_balance()` method returns the ERG balance as a `string`, but parameters can be used to extend or refine the results.

:::info
To avoid data loss due to limitations of JavaScript's default JSON parser, please note that all amounts returned by the dApp Connector are encoded as `strings`, even though they represent `integers`. This ensures the accuracy and integrity of the data being processed.
:::

### Get Balance by `Token ID`

You can pass a `Token ID` as the parameter of the `get_balance()` method to get the balance of a specific token.

```ts
const sigUsdBalance = await ergo.get_balance(
  "03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04"
);
```

### Get Balance for All Assets

To get the balance off all assets held by the connected wallet, pass the constant `all` as the parameter of the `get_balance()` method.

```ts
const fullBalance = await ergo.get_balance("all");
```

The code above returns an `array` with the balance of all assets owned by the connected wallet, following this structure:

```ts
{ tokenId: string, balance: string }[];
```

## Get Addresses

To retrieve wallet addresses, you can use the following methods:

* **`ergo.get_change_address()`**: this method returns the wallet's primary address.
* **`ergo.get_used_addresses()`**: this method returns an `array` of used addresses.
* **`ergo.get_unused_addresses()`**: this method returns an `array` of unused addresses.

## Get UTxOs

You can use the `ergo.get_utxos()` method to fetch unspent UTxOs owned by the selected wallet.

```ts
const utxos = await ergo.get_utxos();
```

The code above returns an array of all UTxOs owned by the selected wallet.

### UTxO Type Definitions

```ts
interface Box {
  boxId: string;
  transactionId: string;
  index: number;
  ergoTree: string;
  creationHeight: number;
  value: string;
  assets: { tokenId: string; amount: string }[];
  additionalRegisters: Partial<Record<"R4" | "R5" | "R6" | "R7" | "R8" | "R9", string>>;
  confirmed?: boolean; // true if included in the blockchain
}
```

### Filter UTxOs

The `get_utxos()` method supports filters by `Token ID` and `amount`. The code below fetches all UTxOs containing the SigUSD token.

```ts
const sigUSDTokenId = "03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04";
const sigUsdUtxos = await ergo.get_utxos({ tokens: [{ tokenId: sigUSDTokenId }] }); // [!code focus]
```

If needed, a target amount can be specified, so that the wallet returns UTxOs until the target is met.

```ts
const sigUSDTokenId = "03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04";
const sigUsdUtxos = await ergo.get_utxos({
  tokens: [
    {
      tokenId: sigUSDTokenId,
      amount: "100" // [!code focus]
    }
  ]
});
```

:::tip
Note that the `tokens` property is an `array`, which means you can filter by various tokens in the same call.
:::

## Get the Current Height

The current height stands for the latest block number included in the blockchain. This is necessary for transaction building.

You can make use of `ergo.get_current_height()` to get it.

```ts
const currentHeight = await ergo.get_current_height();
```

## Sign a Transaction

You can request a transaction signature by calling the `ergo.sign_tx()` method and passing an unsigned transaction object as parameter.

```ts
const unsignedTransaction = new TransactionBuilder(currentHeight)
  .from(inputs)
  .to(new OutputBuilder(1000000n, recipientAddress))
  .sendChangeTo(changeAddress)
  .payMinFee()
  .build()
  .toEIP12Object();

const signedTransaction = await ergo.sign_tx(unsignedTransaction); // [!code focus]
```

When `ergo.sign_tx()` is called, a pop-up window will be displayed to the user, asking them to review and sign the transaction. If the user signs it successfully, the method will return a signed transaction `object` that can be submitted to the blockchain. Otherwise, it will throw an exception.

:::info
As the focus of this guide is specifically on the **dApp Connector** protocol, we will not cover the details of the transaction-building process. For more information on transaction building, please refer to the [Fleet SDK documentation](https://fleet-sdk.github.io/docs/transaction-building).
:::

### Unsigned Transaction Type Definitions

The `sign_tx()` method requires the transaction object to be structured in a slightly different way than what's required by the node: the `inputs` and `dataInputs` properties must be full [Box objects](#utxo-type-definitions), instead of an object containing the `BoxID`.

```ts
interface UnsignedTransaction {
  inputs: Array<{
    boxId: string;
    transactionId: string;
    index: number;
    ergoTree: string;
    creationHeight: number;
    value: string;
    assets: TokenAmount[];
    additionalRegisters: NonMandatoryRegisters;
    extension: { values?: Record<string, string> };
  }>;

  dataInputs: Array<{
    boxId: string;
    transactionId: string;
    index: number;
    ergoTree: string;
    creationHeight: number;
    value: string;
    assets: TokenAmount[];
    additionalRegisters: NonMandatoryRegisters;
  }>;

  outputs: Array<{
    ergoTree: string;
    creationHeight: number;
    value: string;
    assets: TokenAmount[];
    additionalRegisters: NonMandatoryRegisters;
  }>;
}

type TokenAmount = Array<{ tokenId: string; amount: string }>;
type NonMandatoryRegisters = Partial<Record<"R4" | "R5" | "R6" | "R7" | "R8" | "R9", string>>;
```

### Submit a Transaction

Now you have a signed transaction you can submit it to the blockchain using the `ergo.submit_tx()` method.

```ts
// ...
const transactionId = await ergo.submit_tx(signedTransaction);
```

If the transaction is successfully accepted by the mempool, a `string` containing the `Transaction ID` will be returned otherwise, it will throw an exception.

## Sign Arbitrary Data

Nautilus supports arbitrary data signing through the `ergo.sign_data()` method. This method takes two arguments to prompt the user for a signature:

1. **`address`**: The address from which the data should be signed.
2. **`data`**: The data to be signed, which can be either a `string`, a `number`, a `JSON` object, or an `array` or them.

```ts
const address = await ergo.get_change_address();
const data = { foo: "bar", baz: 1 };
const proof = await ergo.sign_data(address, data); // [!code focus]
```

The code above asks Nautilus to prompt the user to review and sign the data. If the user signs it successfully, the method will return the signature proof as a hexadecimal `string` that can be further verified by a prover. Otherwise, it will throw an exception.

### Verify Data Signature

The `sign_data()` method uses the [EIP-44](https://github.com/ergoplatform/eips/blob/master/eip-0044.md) standard to sign arbitrary data. To verify signatures, you'll need a prover that supports this standard. Currently, only the [Fleet SDK](https://github.com/fleet-sdk/fleet) supports it. Below is an example of how you can verify a data signature generated by Nautilus.

```ts
import { Prover } from "@fleet-sdk/wallet";
import { ErgoAddress, ErgoMessage } from "@fleet-sdk/core";

// ...

const prover = new Prover();
const data = ErgoMessage.fromData({ foo: "bar", baz: 1 });
const [publicKey] = ErgoAddress.decode(address).getPublicKeys();

const verified = prover.verify(data, proof, publicKey);
```

:::info
Note that the `address`, `data`, and `proof` must be the same as in the signing step.
:::
